#include <staff_window.hpp>

enum MAIN {
    MAIN_CLASS,
    MAIN_COURSE,
    MAIN_LECT,
    MAIN_BACK,
    CLASS_FRAME,
    COURSE_FRAME,
    COURSE_BACK_BUTTON
};

const vector < string > maincomp {
    "     CLASS MANAGING      ",
    "     COURSE MANAGING     ",
    "    LECTURER MANAGING    ",
    "         LOGOUT          "
};

rectangle StaffWindow::win[11];

/*  *   *   *   *   *   *   *   *   *   OverAll   *   *   *   *   *   *   *   *   */

void StaffWindow::init() {
    win[MAIN_CLASS].set(LINES / 3 + 6, COLS / 2 - 16, 3, 27);
    win[MAIN_COURSE].set(win[MAIN_CLASS].bottom() + 1, win[MAIN_CLASS].left(), 3, 27);
    win[MAIN_LECT].set(win[MAIN_COURSE].bottom() + 1, win[MAIN_CLASS].left(), 3, 27);
    win[MAIN_BACK].set(win[MAIN_LECT].bottom() + 1, win[MAIN_COURSE].left(), 3, 27);
    win[CLASS_FRAME].set(LINES / 3 + 5, COLS / 2 - 20, 20, 40);
}

void StaffWindow::updateMainPtr(int ptr, int stat, int end) {
    for (int i = stat; i <= end; ++i) {
        win[i].drawEdges();
        if (i == ptr) attron(A_REVERSE);
        mvaddstr(win[i].top() + 1, win[i].left() + 1, maincomp[i].c_str());
        if (i == ptr) attroff(A_REVERSE);
    }
    refresh();
}

void StaffWindow::load() {
    init();
    Graphic::Windows::clear(LINES / 3 + 1, 1, LINES - LINES / 3 - 3, COLS - 2);
    //win[MAIN_CLASS].drawEdges();

    int curPtr = 0, lim = 4;
    while (true) {
        int input = getch();
        if (input == KEY_DOWN) {
            curPtr = (curPtr + 1) % lim;
        } else if (input == KEY_UP) {
            curPtr = (curPtr - 1 + lim) % lim;
        } else if (input == ' ' || input == '\n') {
            if (curPtr == 0) {
                Class::load();
                //mvprintw(1, 1, "exit class manager");
            } else if (curPtr == 1) {
                Course::load();
                //mvprintw(1, 1, "exit course manager");
            }
            else if (curPtr == 2) {
                Lecture::load();
                //mvprintw(1, 1, "exit lecturer manager");
            } else break;
        }
        updateMainPtr(curPtr, 0, 3);
    }
    Graphic::Windows::clear(win[MAIN_CLASS].top(), 1, LINES - win[MAIN_CLASS].bottom() - 2, COLS - 2);
}

/*  *   *   *   *   *   *   *   *   *   Class   *   *   *   *   *   *   *   *   */
void StaffWindow::Class::load() {
    Graphic::Windows::clear(LINES / 3 + 1, 1, LINES - LINES / 3 - 3, COLS - 2);
    vector <string> classComps = Staff::Classes::getClassList();
    
    
    //Insert space-----------------------------
    vector <string> classCompsLine;
    for (int i = 0; i <= classComps.size(); ++i) {
        string classSub;
        if (i == classComps.size())
            classSub = "[BACK]";
        else
            classSub = classComps[i];
        
        int sizeSpace = win[CLASS_FRAME].right()-win[CLASS_FRAME].left()-classSub.size()-1;
        for (int j = 1; j <= sizeSpace/2; ++j)
            classSub = " " + classSub + " ";
        if (sizeSpace % 2 == 1)
            classSub = classSub + " ";
        classCompsLine.push_back(classSub);
    }
    int size = classCompsLine.size();
    //------------------------------------------
    
    
    int curPtr = 0;
    while (true) {
        int input = getch();
        bool exitWhile = false;
        
        switch (input) {
            case KEY_DOWN:
                curPtr = (curPtr + 1) % size;
                break;
            case KEY_UP:
                curPtr = (curPtr - 1  + size) % size;
                break;
            case '\n': {
                if (curPtr == size - 1) {
                    exitWhile = true;
                    break;
                }
                
                display(classComps[curPtr]);
                break;
            }
        }
        
        
        //If user choose [BACK], then finish this function
        if (exitWhile)
            break;
        
        
        //Update Pointer--------------------------
        win[CLASS_FRAME].drawEdges();
        for (int i = 0; i < size; ++i) {
            if (i == curPtr)
                attron(A_REVERSE);
            
            if (i == size - 1)
                mvprintw(win[CLASS_FRAME].bottom() - 2, win[CLASS_FRAME].left() + 1, classCompsLine[i].c_str());
            else
                mvprintw(win[CLASS_FRAME].top() + 5+i, win[CLASS_FRAME].left() + 1, classCompsLine[i].c_str());
            
            if (i == curPtr)
                attroff(A_REVERSE);
        }
    }
    
    
    Graphic::Windows::clear(LINES / 3 + 1, 1, LINES - LINES / 3 - 3, COLS - 2);
}

void StaffWindow::Class::display(string a) {
    classDisplay(a);
}

/*  *   *   *   *   *   *   *   *   *   Course   *   *   *   *   *   *   *   *   */

void StaffWindow::Course::load() {
    Graphic::Windows::clear(LINES / 3 + 1, 1, LINES - LINES / 3 - 3, COLS - 2);

    vector <string> text {
        "   VIEW COURSES   ",
        "    ADD COURSE    ",
        "       BACK       ",
    };
    rectangle cwin[5];
    cwin[0].set(LINES / 3 + 6, COLS / 2 - 23, 15, 45);
    cwin[1].set(cwin[0].top() + 3, cwin[0].left() + cwin[0].width() / 2 - text[0].size() / 2 - 1, 3, text[0].size() + 2);
    cwin[2].set(cwin[1].bottom() + 1, cwin[1].left(), 3, cwin[1].width());
    cwin[3].set(cwin[2].bottom() + 1, cwin[1].left(), 3, cwin[1].width());

    auto updateptr = [&](int ptr, int stat, int end) {
        cwin[0].drawEdges();
        for (int i = stat; i <= end; ++i) {
            cwin[i + 1].drawEdges();
            if (i == ptr) attron(A_REVERSE);
            mvaddstr(cwin[i + 1].top() + 1, cwin[i + 1].left() + 1, text[i].c_str());
            if (i == ptr) attroff(A_REVERSE);
        }
        refresh();
    };

    int curPtr = 0;
    while (true) {
        int input = getch();
        if (input == KEY_UP) {
            curPtr = (curPtr - 1 + 3) % 3;
        } else if (input == KEY_DOWN) {
            curPtr = (curPtr + 1) % 3;
        } else if (input == '\n' || input == ' ') {
            if (curPtr == 0) CourseWindow::display();
            else if (curPtr == 1) CourseWindow::add();
            else break;
        }
        updateptr(curPtr, 0, 2);
    }
    Graphic::Windows::clear(LINES / 3 + 1, 1, LINES - LINES / 3 - 3, COLS - 2);
}

/*  *   *   *   *   *   *   *   *   *   Lecurer   *   *   *   *   *   *   *   *   */

void StaffWindow::Lecture::load() {
    Graphic::Windows::clear(LINES/3 + 1, 1, LINES - LINES/3 - 3, COLS - 2);

    rectangle cwin;
    cwin.set(LINES/2 - 6, COLS/2 - 36, 24, 80);
    cwin.drawEdges();

    vector < vector <string> > comps;
    //comps.push_back(vector <string> {"Account", "First name", "Last name", "Gender", "DoB"});

    mvaddstr(cwin.top() + 2, cwin.left() + 10, "Account     First name   Last name     Gender         DoB");
    
    ifstream fin("data/lecturers_list");
    string s;
    while (getline(fin, s)) {
        if (!isdigit(s.back())) s.pop_back();
        vector <string> cur = Utils::Tool::getElement(s + " ", ' ');
        comps.push_back(cur);
    }

    auto updateptr = [&](int ptr, int stat, int end) {
        mvaddstr(cwin.top() + 2, cwin.left() + 10, "Account     First name   Last name     Gender         DoB");
        cwin.drawEdges();
        if (ptr > end) {
            attron(A_REVERSE);
            mvaddstr(cwin.bottom() - 2, cwin.left() + cwin.width() / 2 - 8, "   [  BACK  ]   ");
            attroff(A_REVERSE);
        } else {
            mvaddstr(cwin.bottom() - 2, cwin.left() + cwin.width() / 2 - 8, "   [  BACK  ]   ");
        }
        for (int i = stat; i <= end; ++i) {
            if (i == ptr) attron(A_REVERSE);
            for (int k = cwin.left() + 1; k < cwin.right(); ++k)
                mvaddch(cwin.top() + 3 + i, k, ' ');
            int y = cwin.width() / (int) (comps[i].size() + 1);
            for (int k = 0; k < (int) comps[i].size(); ++k)
                mvaddstr(cwin.top() + 3 + i, cwin.left() + y * (k + 1) - comps[i][k].size() / 2, comps[i][k].c_str());
            if (i == ptr) attroff(A_REVERSE);
        }
        refresh();
    };

    int curPtr = 0, lim = comps.size() + 1;
    while (true) {
        int input = getch();
        if (input == KEY_UP) {
            curPtr = (curPtr - 1 + lim) % lim;
        } else if (input == KEY_DOWN) {
            curPtr = (curPtr + 1) % lim;
        } else if (input == '\n' || input == ' ') {
            if (curPtr == lim - 1) {
                break;
            } else {
                rectangle xwin;
                xwin.set(LINES / 2, COLS / 2 - 20, 3, 50);
                Graphic::Windows::clear(xwin);
                xwin.drawEdges();
                attron(A_BLINK);
                mvaddstr(xwin.top() + 1, xwin.left() + 5, " Press R to remove or press C to cancel!    ");
                attroff(A_BLINK);
                refresh();
                while (true) {
                    int xx = getch();
                    mvprintw(1, 1, "%d %d %d", xx, 'c', 'r');
                    if (xx == 'C' || xx == 'c') {
                        break;
                    } else if (xx == 'r' || xx == 'R') {
                        comps.erase(comps.begin() + curPtr);
                        for (int k = cwin.left() + 1; k < cwin.right(); ++k)
                            mvaddch(cwin.top() + 3 + curPtr, k, ' ');
                        refresh();
                        lim--;
                        Staff::updateData("data/lecturers_list", comps);
                        break;
                    }
                }
                Graphic::Windows::clear(cwin);
                refresh();
            }
        }
        updateptr(curPtr, 0, lim - 2);
    }
    
    Graphic::Windows::clear(LINES/3 + 1, 1, LINES - LINES/3 - 3, COLS - 2);
}